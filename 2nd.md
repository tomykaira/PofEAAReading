第二回 - 5章から8章まで

# 5. 並行性

複数のアクティブエージェントが同じデータにアクセスし、競合するという問題。

- テスト困難
- EA 開発ではトランザクション管理によって楽ができる(e.g. DB)
- **オフライン並行性**: データが複数のトランザクション間にまたがること。並行性の問題が再発する
- アプリケーションサーバの並行性

## 5.1. 並行性の問題

- 更新結果の喪失 (WAW)
- 一貫性のない読み込み (WAR)

安全性、即応性の両方が求められる。銀の弾丸はないので、事案によってどちらに寄せるかを判断する必要がある。
出典が見つけられなかったが、どこかのソーシャルゲームでは高速化のために KVS (たしか memcache) を使い、一貫性が担保できない部分はかならずユーザの有利になるように調整しているそう。

## 5.2. 実行コンテキスト

- リクエスト: ソフトウェアが動作する外界からの呼出
- セッション: クライアントとサーバが一定時間内に相互作用すること。論理的な処理のかたまりというイメージ

技術的な視点

- プロセス vs. スレッド
- スレッドプール
- トランザクション: リクエストをまとめる

## 5.3. 分離性および不変性

分離: あるプロセスが作用する領域を他から分離する。ロックなど

不変データ: 不変なデータは並行性を考慮せず共有しても安全。不変な / 不変にできるデータを認知してそのように扱う

## 5.4. 軽い並行性制御および重い並行性制御

変更でき、分離できないデータに対する対処。

- 軽ロック: 書き込みでのみ競合検知。コンフリクトを検知する。コンフリクトしたら大抵最初からやりなおさねばならない。
  最近の VCS で一般的。
- 重ロック: 読み込み時にロックを取得し、書き込み終了で手放す。コンフリクトを生じさせない。
  プログラム内のメモリ管理で一般的。

### 一貫性のない読み込みの防止

読み込みにつづく書き込みの結果、一貫性がうしなわれる場合

- 軽ロック: 書き込み時にかならず更新されるデータを用いてコンフリクト検出
- 重ロック: Reader-Writer スタイルのロック

(軽: optimistic、重: pessimistic だったらしい。わからねー)

すべてのデータでロック or コンフリクト検出をするとコストがかかるので、ビジネス的に関連が重要であるデータだけに限定するべき。
このようなデータ群を十分な考察が必要になり、機械的に導出することは難しい。

一時的読み込み: タイムスタンプを用いて、ある時点での一貫したデータ群が取得できることを保証する。
e.g. VCS のバージョン番号

### デッドロック

こわい。

EA ではできるだけシンプルかつ慎重な手法を使用することが推奨される。

## トランザクション

トランザクション可能なリソース = トランザクション機能を持つ = (ここでの) データベース

- 開始地点と終了地点が明確に定義された一連の連続した動作
- ACID

### トランザクションの種類

- リクエストトランザクション: 一般的、推奨
- ロングトランザクション: 複数のリエクストを含む。避けたほうがいい
- 遅延トランザクション: 一貫性のない読み込みが発生しうる。意図がある場合以外は避ける

ロックエスカレーション: データベースが小さい粒度のロックを多数おこなうかわりに、大きい粒度のロックひとつでおきかえること。
結果テーブル全体がロックされ、他のトランザクションがロックアウトされる。
ドメインのレイヤスーパータイプ(p.497, レイヤのすべてのタイプに対してスーパータイプとしての役割をはたすもの)レベルにはデータ用の「オブジェクト」テーブルを置くべきではない。

[ロック エスカレーション＝悪ではない（ロック エスカレーションの真実） SQL Server - 松本崇博 Blog （SQL Server Tips）](http://d.hatena.ne.jp/matu_tak/20100325/1269543991)

### 分離レベル

    locking:    7 -> 9
    multiphase: 5 -> 8

- 直列化可能: 並行実行しても逐次実行とおなじ結果が得られる
- 繰り返し可能な読み込み: locking で 7、 multiphase で 8 を読む場合がある(phantom read)。同一トランザクション内では値はおなじ
- コミットされた読み込み: 同一読み込みトランザクション内でも読み込む値が変化しうる
- コミットされていない読み込み: トランザクションなんてなかった

[トランザクション分離レベル - Wikipedia](https://ja.wikipedia.org/wiki/トランザクション分離レベル)

精度を確保したい場合は直列化可能を使うべきだが、即応性に重大な影響を与えるので、場合によっては妥協する。


### ビジネストランザクション

複数のリクエストをまたぐ場合にやっかい(オフライン並行性の問題)。
並行性がそれほど必要とされていない場合にはロングトランザクションを使うと楽。後からショートトランザクションに戻すのは困難。

- A,D : 容易
- C: ドメインモデルの場合はユニットオブワークで変更を記録する
- I: ビジネストランザクションの終了まで、ユーザの作業を無効な状態にしておく

## 5.6 オフライン並行性制御のためのパターン

できれば、ビジネストランザクション = リクエスト = システムトランザクションになるようにする。

Coarse-Grained Lock: オブジェクトグループをまとめる。オブジェクトの関連についてのドメインの知識が必要。

pessimistic / optimistic は user experience に関係するので、技術的な視点で決めることはよろしくない。

## 5.7. アプリケーションサーバの並行性

process pool を使用した process per request が楽。現在もよく使われている。
アプリケーションサーバの問題は計算リソースを投入することで解消できる。
スレッドを使う場合は各オブジェクトをスレッドローカルにするとよい。
生成コストが大きいオブジェクトにはプールを使う(ex. DB connection pool)

最近ではひとつのプロセスで複数のリクエストをさばくフレームワークが出てきている。
基盤には epoll などのポーリングシステムコールを使い、イベント処理ライブラリで処理するパターンが多い。
nginx、node.js など。

# 6. セッションステート

ビシネストランザクション vs. システムトランザクション = ステートフルセッション vs. ステートレスセッション

## 6.1. ステートレス性の価値

- stateless object: フィールドを持たない
- stateless server: フィールドを持つかもしれないが、リクエストが終わったら無効
- stateful server: リクエストの間をまたいで有効。おなじセッションはおなじサーバオブジェクトが担当しなければならない

一般的な WAF ではステートフルサーバを構築し、意図どおり動作させることが非常にむずかしい。

可能な場合はステートレスにすべきだが、クライアントとのやり取りは本質的にステートフルという問題。

## 6.2. セッションステート

特定のセッションに関連した、ビシネストランザクション内にある状態。
レコードデータは他から見えるが、セッションステートは見えない。コミットされることでレコードデータになる。

- クライアントに格納: URL, cookie, hidden fields
- サーバに格納: サーバのメモリやローカルファイルシステム
- DB に格納: 最近は高速な KVS などを利用する例がある

大抵の WAF はセッションを管理するためのしくみを提供しているので、それを使う。ただし容量やデータの有効期間、セキュリティに注意。

複数のアプリケーションサーバがある場合、どのサーバが処理してもいいようにセッションを共有できる必要がある(セッション移行)。
かならず同一のサーバでセッションを処理する方法もある(サーバアフィニティ)。ロードバランサがはさまったり、HTTP サーバとアプリケーションサーバが違う場合など、実際に効率よく動作させるのはむずかしい。

# 7. 分散ストラテジー

## 7.1. 分散オブジェクトの誘惑

透過的な分散によりパフォーマンスが向上するという誤謬。

## 7.2. リモートインタフェースとローカルインタフェース

同じプロセスとそれ以外では呼出速度がおおきく異なるので、インタフェースを明示的に区別する必要がある。
分散構成でのパフォーマンスの要求は OOP の原則に反するため。
「オブジェクトを分散させてはいけない」

複数のプロセッサやマシンを有効に活用するには、かわりに同一のプロセスを複数 parallel に実行する。

## 7.3. 分散が必要な場所

- クライアントとサーバ(スタンダロンでないアプリケーションではかならず存在)
- アプリケーションサーバと DB(ふつう行う)
- web サーバとアプリケーションサーバ(apache / nginx + WAF用のサーバ)

メインアプリケーションと、それに付随する、一部の操作が可能で別の種類のユーザに開かれた複数のインタフェースがあるという構成について。
別のインタフェースが別のアプリケーションで実現されていると、DB を介するか、メインアプリケーションの API を介するかしてやりとりする必要がある。
このような構成はデバッグしにくく、コードの重複が発生しがちで、デプロイ戦略も難しい。
メインアプリケーションがダウンしたら他も使えなくなるので、堅牢性が向上しているわけでもない。
本当はメインアプリケーションにすべてを統合し、その枠組みのなかでアクセス権制御をおこなうようにしたほうがよかった。

## 7.4. 分散境界の扱い

- リモートファサード: 分散のための粒度の粗いファサードオブジェクト
- データ変換オブジェクト: 粗い粒度のオブジェクトを転送する方法

## 7.5. 分散用インタフェース

XML over HTTP が増えてきている。最近はそれが JSON や MessagePack になってきている。
しかしデータ構造を encode / decode する負荷は大きい。

同じプラットフォームの場合は、バイナリを直接転送するなどより直接的な方法を取るほうがいい。
Ruby では dRuby など。

非同期メッセージングも考えられる。
public な API での使用例はあまり見受けないが、 Twitter の streaming API は HTTP をつなぎっぱなしにしてデータが到着ししだい転送してくれる。受け取り手は非同期的な手法を使ってプログラミングする必要がある。

# 8. まとめ

いま直面している問題を解決できるのはその人自身である。この本は指標、触媒にすぎない。

## 8.1. ドメインレイヤからの開始

どのドメインロジック手法で行くかを決定する [トランザクションスクリプト、テーブルモジュール、ドメイモデル]
ドメインロジックの複雑性、DB との接続のむずかしさなどを基準に決定する。

## 8.2. データソースレイヤに進む

- トランザクションスクリプト用: [行データゲートウェイ、テーブルゲートウェイ]
  - unit of work はスクリプト内で管理しきれるだろうから不要
  - オフライン並行性がある場合は簡単な軽オフラインロック
- テーブルモジュール用: テーブルデータゲートウェイ
  - テーブルモジュールの選択はよいレコードセットフレームワークを前提にしている
  - レコードセットが並行性制御や unit of work の機能をになってくれるので、他のテクニックは不要
- ドメインモデル用: [アクティブレコード、データマッパー]
  - active record は構成がシンプルな場合に適切
  - data mapper は複雑。マッピングツールを使う。 unit of work を導入したほうがいい

## 8.3. プレゼンテーションレイヤ

リッチクライアント or HTML。本書では後者のみ扱う。

MVC 構造にする。

コントローラは通常フレームワークが提供するものをそのまま使う [ページコントローラ、フロントコントローラ]

- ページコントローラ(p.354): 静的ページと動的ページがまざっている場合に向く
- フロントコントローラ(p.366): 遷移が複雑な場合

## 8.4. 技術上のアドバイス

Web サービスについて、複数の Web サービスが協働してひとつのアプリケーションになるのではなく、ひとつのアプリケーションがあり、それに対するエントリポイントが複数の web サービスであるような構成にすべき、と言っているように見える。
単一のドメインロジックを持つ大きなアプリケーションに対し、複数の controller + view を用意するイメージ?
たしかに有効そうだが、フレームワークによってはうまく構成できないかもしれない。

## 8.5. その他のレイヤ化スキーム

### Brown model

- プレゼンテーション
- コントローラ / メディエータ : とりつぎ
- ドメイン
- データマッピング  : とりつぎ
- データソース

Fowler のアイディアではとりつぎ層は常に必要なわけではないので、パターンにしている。

### CoreJ2EE

- クライアント : Fowler は明示していないが、プレゼンテーション
- プレゼンテーション
- ビジネス
- 統合
- リソース

などなど

Fowler の設定しているレイヤは最低限のものであり、他のレイヤ化スキームはこのレイヤを分割している。
Fowler はこのような分割をパターンとして提供し、アプリケーションの目的や複雑さに応じて柔軟に調整できるようなフレームワークを作っている。
