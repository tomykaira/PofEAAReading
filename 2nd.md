第二回 - 5章から8章まで

# 5. 並行性

複数のアクティブエージェントが同じデータにアクセスし、競合するという問題。

- テスト困難
- EA 開発ではトランザクション管理によって楽ができる(e.g. DB)
- **オフライン並行性**: データが複数のトランザクション間にまたがること。並行性の問題が再発する
- アプリケーションサーバの並行性

## 5.1. 並行性の問題

- 更新結果の喪失 (WAW)
- 一貫性のない読み込み (WAR)

安全性、即応性の両方が求められる。銀の弾丸はないので、事案によってどちらに寄せるかを判断する必要がある。
出典が見つけられなかったが、どこかのソーシャルゲームでは高速化のために KVS (たしか memcache) を使い、一貫性が担保できない部分はかならずユーザの有利になるように調整しているそう。

## 5.2. 実行コンテキスト

- リクエスト: ソフトウェアが動作する外界からの呼出
- セッション: クライアントとサーバが一定時間内に相互作用すること。論理的な処理のかたまりというイメージ

技術的な視点

- プロセス vs. スレッド
- スレッドプール
- トランザクション: リクエストをまとめる

## 5.3. 分離性および不変性

分離: あるプロセスが作用する領域を他から分離する。ロックなど

不変データ: 不変なデータは並行性を考慮せず共有しても安全。不変な / 不変にできるデータを認知してそのように扱う

## 5.4. 軽い並行性制御および重い並行性制御

変更でき、分離できないデータに対する対処。

- 軽ロック: 書き込みでのみ競合検知。コンフリクトを検知する。コンフリクトしたら大抵最初からやりなおさねばならない。
  最近の VCS で一般的。
- 重ロック: 読み込み時にロックを取得し、書き込み終了で手放す。コンフリクトを生じさせない。
  プログラム内のメモリ管理で一般的。

### 一貫性のない読み込みの防止

読み込みにつづく書き込みの結果、一貫性がうしなわれる場合

- 軽ロック: 書き込み時にかならず更新されるデータを用いてコンフリクト検出
- 重ロック: Reader-Writer スタイルのロック

(軽: optimistic、重: pessimistic だったらしい。わからねー)

すべてのデータでロック or コンフリクト検出をするとコストがかかるので、ビジネス的に関連が重要であるデータだけに限定するべき。
このようなデータ群を十分な考察が必要になり、機械的に導出することは難しい。

一時的読み込み: タイムスタンプを用いて、ある時点での一貫したデータ群が取得できることを保証する。
e.g. VCS のバージョン番号

### デッドロック

こわい。

EA ではできるだけシンプルかつ慎重な手法を使用することが推奨される。

## トランザクション

トランザクション可能なリソース = トランザクション機能を持つ = (ここでの) データベース

- 開始地点と終了地点が明確に定義された一連の連続した動作
- ACID

### トランザクションの種類

- リクエストトランザクション: 一般的、推奨
- ロングトランザクション: 複数のリエクストを含む。避けたほうがいい
- 遅延トランザクション: 一貫性のない読み込みが発生しうる。意図がある場合以外は避ける

ロックエスカレーション: データベースが小さい粒度のロックを多数おこなうかわりに、大きい粒度のロックひとつでおきかえること。
結果テーブル全体がロックされ、他のトランザクションがロックアウトされる。
ドメインのレイヤスーパータイプ(p.497, レイヤのすべてのタイプに対してスーパータイプとしての役割をはたすもの)レベルにはデータ用の「オブジェクト」テーブルを置くべきではない。

[ロック エスカレーション＝悪ではない（ロック エスカレーションの真実） SQL Server - 松本崇博 Blog （SQL Server Tips）](http://d.hatena.ne.jp/matu_tak/20100325/1269543991)

### 分離レベル

    locking:    7 -> 9
    multiphase: 5 -> 8

- 直列化可能: 並行実行しても逐次実行とおなじ結果が得られる
- 繰り返し可能な読み込み: locking で 7、 multiphase で 8 を読む場合がある(phantom read)。同一トランザクション内では値はおなじ
- コミットされた読み込み: 同一読み込みトランザクション内でも読み込む値が変化しうる
- コミットされていない読み込み: トランザクションなんてなかった

[トランザクション分離レベル - Wikipedia](https://ja.wikipedia.org/wiki/トランザクション分離レベル)

精度を確保したい場合は直列化可能を使うべきだが、即応性に重大な影響を与えるので、場合によっては妥協する。


### ビジネストランザクション

複数のリクエストをまたぐ場合にやっかい(オフライン並行性の問題)。
並行性がそれほど必要とされていない場合にはロングトランザクションを使うと楽。後からショートトランザクションに戻すのは困難。

- A,D : 容易
- C: ドメインモデルの場合はユニットオブワークで変更を記録する
- I: ビジネストランザクションの終了まで、ユーザの作業を無効な状態にしておく

## 5.6 オフライン並行性制御のためのパターン

できれば、ビジネストランザクション = リクエスト = システムトランザクションになるようにする。

Coarse-Grained Lock: オブジェクトグループをまとめる。オブジェクトの関連についてのドメインの知識が必要。

pessimistic / optimistic は user experience に関係するので、技術的な視点で決めることはよろしくない。

## 5.7. アプリケーションサーバの並行性

process pool を使用した process per request が楽。現在もよく使われている。
アプリケーションサーバの問題は計算リソースを投入することで解消できる。
スレッドを使う場合は各オブジェクトをスレッドローカルにするとよい。
生成コストが大きいオブジェクトにはプールを使う(ex. DB connection pool)

最近ではひとつのプロセスで複数のリクエストをさばくフレームワークが出てきている。
基盤には epoll などのポーリングシステムコールを使い、イベント処理ライブラリで処理するパターンが多い。
nginx、node.js など。

# 6. セッションステート

ビシネストランザクション vs. システムトランザクション = ステートフルセッション vs. ステートレスセッション

## 6.1. ステートレス性の価値

- stateless object: フィールドを持たない
- stateless server: フィールドを持つかもしれないが、リクエストが終わったら無効
- stateful server: リクエストの間をまたいで有効。おなじセッションはおなじサーバオブジェクトが担当しなければならない

一般的な WAF ではステートフルサーバを構築し、意図どおり動作させることが非常にむずかしい。

可能な場合はステートレスにすべきだが、クライアントとのやり取りは本質的にステートフルという問題。

## 6.2. セッションステート

特定のセッションに関連した、ビシネストランザクション内にある状態。
レコードデータは他から見えるが、セッションステートは見えない。コミットされることでレコードデータになる。

- クライアントに格納: URL, cookie, hidden fields
- サーバに格納: サーバのメモリやローカルファイルシステム
- DB に格納: 最近は高速な KVS などを利用する例がある

大抵の WAF はセッションを管理するためのしくみを提供しているので、それを使う。ただし容量やデータの有効期間、セキュリティに注意。

複数のアプリケーションサーバがある場合、どのサーバが処理してもいいようにセッションを共有できる必要がある(セッション移行)。
かならず同一のサーバでセッションを処理する方法もある(サーバアフィニティ)。ロードバランサがはさまったり、HTTP サーバとアプリケーションサーバが違う場合など、実際に効率よく動作させるのはむずかしい。

# 7. 分散ストラテジー
