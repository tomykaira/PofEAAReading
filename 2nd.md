第二回 - 5章から8章まで

# 5. 並行性

複数のアクティブエージェントが同じデータにアクセスし、競合するという問題。

- テスト困難
- EA 開発ではトランザクション管理によって楽ができる(e.g. DB)
- **オフライン並行性**: データが複数のトランザクション間にまたがること。並行性の問題が再発する
- アプリケーションサーバの並行性

## 5.1. 並行性の問題

- 更新結果の喪失 (WAW)
- 一貫性のない読み込み (WAR)

安全性、即応性の両方が求められる。銀の弾丸はないので、事案によってどちらに寄せるかを判断する必要がある。
出典が見つけられなかったが、どこかのソーシャルゲームでは高速化のために KVS (たしか memcache) を使い、一貫性が担保できない部分はかならずユーザの有利になるように調整しているそう。

## 5.2. 実行コンテキスト

- リクエスト: ソフトウェアが動作する外界からの呼出
- セッション: クライアントとサーバが一定時間内に相互作用すること。論理的な処理のかたまりというイメージ

技術的な視点

- プロセス vs. スレッド
- スレッドプール
- トランザクション: リクエストをまとめる

## 5.3. 分離性および不変性

分離: あるプロセスが作用する領域を他から分離する。ロックなど

不変データ: 不変なデータは並行性を考慮せず共有しても安全。不変な / 不変にできるデータを認知してそのように扱う

## 5.4. 軽い並行性制御および重い並行性制御

変更でき、分離できないデータに対する対処。

- 軽ロック: 書き込みでのみ競合検知。コンフリクトを検知する。コンフリクトしたら大抵最初からやりなおさねばならない。
  最近の VCS で一般的。
- 重ロック: 読み込み時にロックを取得し、書き込み終了で手放す。コンフリクトを生じさせない。
  プログラム内のメモリ管理で一般的。

### 一貫性のない読み込みの防止

読み込みにつづく書き込みの結果、一貫性がうしなわれる場合

- 軽ロック: 書き込み時にかならず更新されるデータを用いてコンフリクト検出
- 重ロック: Reader-Writer スタイルのロック

すべてのデータでロック or コンフリクト検出をするとコストがかかるので、ビジネス的に関連が重要であるデータだけに限定するべき。
このようなデータ群を十分な考察が必要になり、機械的に導出することは難しい。

一時的読み込み: タイムスタンプを用いて、ある時点での一貫したデータ群が取得できることを保証する。
e.g. VCS のバージョン番号

### デッドロック

