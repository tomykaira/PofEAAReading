# 11th. オブジェクトリレーショナル振る舞いパターン

## 11.1 ユニットオブワーク

> ビジネストランザクションの影響を受けるオブジェクトのリストを保持しつつ、変更点の書き込みと並行性の問題の解決を調整する。

変更点を記録しておき、まとめて DB アクセスを行うことでアクセス負荷を低減する。
複数のリクエストにまたがったビシネストランザクションを扱う。

- オブジェクトの作成、変更、削除を通知
- 並行性チェックの仕組みを持つ
- 一貫性のない読み込みのチェックにも使える

- caller registration: オブジェクトのユーザが変更時に明示的に unit of work に追加
  - 一時データやテストでは unit of work に登録しない
- object registration: set 系メソッドが dirty フラグを立て、 dirty だったら unit of work が処理する。
  アスペクト指向で自動的にオブジェクトに unit of work に登録するコードを追加する方法がある。
  - テストでは専用の unit of work を迂回するコンストラクタを使うか、コミットしない unit of work を使う
- ユニットオブワークコントローラ: 読み込み時のオブジェクトとコミット時のオブジェクトを比較し、変更点があれば書き込み

ユニットオブワークはセッションオブジェクト内に置ける。
スレッドスコープなレジストリが有効。スレッドをまたがないよう注意。

.NET のデータセットではデータ行がバージョンや状態を保持する。
書きこむべきオブジェクトの管理はできるが、並行性の調整はできない?

### 使用するタイミング

- 他の方法
  - 逐次保存
  - オブジェクトごとの不確定フラグ
- 内包・利用
  - オフラインロック

### コード例

- 新規、変更、削除のリストを保持
- それぞれの登録メソッドがある
- commit 時にそれぞれのリストの要素を data mapper で処理
- `ThreadLocal` + singleton
- サーブレット(一般にはコントローラ)の先頭で uow を開始し、おわりに commit する

## 11.2 一意マッピング

> 読み込まれたすべてのオブジェクトを1つのマッピングに保存することで、各オブジェクトが確実に一度だけ読み込まれるようにする。オブジェクトを参照する場合には、マッピングを使って参照する。

一意性を保証しなければいけないオブジェクト(エンティティ)に対して。読み込み負荷を下げる副次効果もある。

「一意マッピングは並行性管理によって相互作用するため、軽オフラインロックについても考慮しなければいけない」 とは?
セッションをまたがる競合の処理にはまったく効果がない(p. 212,最後)

- キー
  - primary key (あれば)
  - 代理 primary key (複合主キーの場合)
- 明示 / 汎用 :
  オブジェクトごとのメソッドか、オブジェクトを引数指定するか。言語にもよりそう
- マッピングの単位 :
  クラスごと or セッション全体。継承がある場合は継承ツリーで一つのほうがよい
- 配置場所 :
  - Unit of Work, セッションにむすびついたレジストリ
  - immutable object を管理するものはプロセスコンテクストのほうが効率的

### 使用するタイミング

- バリューオブジェクトには不要
- 依存マッピング(p.282、依存するオブジェクトを所有者がロードする)では別の形になる

## 11.3 レイジーロード

> 必要なすべてのデータは含まないが、その取得方法を知っているオブジェクト。

最初の読み込み時には、関連する部分の読み込みをある程度で止めておき、あとで必要になってから読み込む。

過剰な DB アクセスが発生しないよう注意。

いくつかのレイジー性がもとめられる場合もあるが、あまり複雑にせず、完全に読み込むか、 id だけか、ぐらいがいい。

### レイジーイニシャライズ

フィールドが null だったら読み込む。

オブジェクトと DB が密結合するので、アクティブレコード、テーブルデータゲートウェイ、行データゲートウェイに適する。

### 仮想プロキシー

データマッパーの場合の間接化。

プロキシと実オブジェクトの対応関係に注意。

コレクションクラスについて使うと問題は少ない。

### バリューホルダー

いくつかのオブジェクトをラップするオブジェクト。最初の要求でだけ DB から読み込み、あとは持っているものを返す。

### ゴースト

最初は ID だけ持っていて、要求されたときにすべてのフィールドを読み込む。
ゴーストを一意マッピングに挿入すれば循環参照問題(chap. 10, p.181)を自然に回避できる。
一部のよくつかうフィールドを読み込んでおいてもいい。

アスペクト指向プログラミングで利用できる。

### 使用するタイミング

そのフィールドを取得すると DB の追加呼び出しが起きるような場合。

コード例はゴースト以外容易に把握できる。ゴーストは概念はシンプルなのに長い…
