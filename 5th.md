# 11th. オブジェクトリレーショナル振る舞いパターン

## 11.1 ユニットオブワーク

> ビジネストランザクションの影響を受けるオブジェクトのリストを保持しつつ、変更点の書き込みと並行性の問題の解決を調整する。

変更点を記録しておき、まとめて DB アクセスを行うことでアクセス負荷を低減する。
複数のリクエストにまたがったビシネストランザクションを扱う。

- オブジェクトの作成、変更、削除を通知
- 並行性チェックの仕組みを持つ
- 一貫性のない読み込みのチェックにも使える

- caller registration: オブジェクトのユーザが変更時に明示的に unit of work に追加
  - 一時データやテストでは unit of work に登録しない
- object registration: set 系メソッドが dirty フラグを立て、 dirty だったら unit of work が処理する。
  アスペクト指向で自動的にオブジェクトに unit of work に登録するコードを追加する方法がある。
  - テストでは専用の unit of work を迂回するコンストラクタを使うか、コミットしない unit of work を使う
- ユニットオブワークコントローラ: 読み込み時のオブジェクトとコミット時のオブジェクトを比較し、変更点があれば書き込み

ユニットオブワークはセッションオブジェクト内に置ける。
スレッドスコープなレジストリが有効。スレッドをまたがないよう注意。

.NET のデータセットではデータ行がバージョンや状態を保持する。
書きこむべきオブジェクトの管理はできるが、並行性の調整はできない(自分でやらないといけない)?

この3つでは object registration にちかい(?)

並行性制御は

- アノテーションで変更を検出して例外を出すようにしたりという調整ができる。
- refresh で変更を事前に検出

### 使用するタイミング

すべての変更にかんする状態を一箇所で管理できるところが強み。

- 他の方法
  - 逐次保存 -- 呼び出し回数の増加
  - 変数にとっておく -- transaction script では機能。 domain model では複雑になり管理しきれない
  - オブジェクトごとの不確定フラグ -- すべてのオブジェクトを訪問して保存処理をする必要。一般に困難
- 内部で利用できる
  - オフラインロック

### コード例

- 新規、変更、削除のリストを保持
- それぞれの登録メソッドがある
- commit 時にそれぞれのリストの要素を data mapper で処理
- `ThreadLocal` + singleton
- サーブレット(一般にはフロントコントローラ)の先頭で uow を開始し、おわりに commit する

## 11.2 一意マッピング

> 読み込まれたすべてのオブジェクトを1つのマッピングに保存することで、各オブジェクトが確実に一度だけ読み込まれるようにする。オブジェクトを参照する場合には、マッピングを使って参照する。

一意性を保証しなければいけないオブジェクト(エンティティ)に対して。読み込み負荷を下げる副次効果もある。

「一意マッピングは並行性管理によって相互作用するため、軽オフラインロックについても考慮しなければいけない」(p.210 先頭) とは?
読み込みの一貫性を確保するために、ビジネストランザクション内ではそのトランザクションが始まった時点でのオブジェクトを返さなければいけない、の意?

セッションをまたがる競合の処理にはまったく効果がない(p. 212,最後)。

### つかううえで決定すべき事項

- キー
  - primary key (あれば)
  - 代理 primary key (複合主キーの場合)
- 明示 / 汎用 :
  オブジェクトごとのメソッドか、オブジェクトを引数指定するか。言語にもよりそう(e.g. 動的に型がつく言語では型チェックの恩恵がなくなる)。
  Fowler は明示がおすすめ。
- マッピングの単位(数) :
  クラスごと or セッション全体。継承がある場合は継承ツリーで一つのほうがよい
- 配置場所 :
  - セッションごとに使い分ける必要があるので、基本的にはセッションにむすびついたレジストリ。 Unit of Work など。
  - immutable object を管理するものはプロセスコンテクストのほうが効率的
  - 負荷がたかくないかぎり分けるのは面倒になりそう

### 使用するタイミング

- バリューオブジェクトには不要(読み込みキャッシュの役割は可能)
- 依存マッピング(p.282、依存するオブジェクトを所有者がロードする)では別の形になる
- セッション間の競合解決のためにはオフラインロックとの同時利用が必要

## 11.3 レイジーロード

> 必要なすべてのデータは含まないが、その取得方法を知っているオブジェクト。

最初の読み込み時には、関連する部分の読み込みをある程度で止めておき、あとで必要になってから読み込む。

過剰な DB アクセスが発生しないよう注意。

いくつかの laziness がもとめられる場合もあるが、あまり複雑にせず、完全に読み込むか、 id だけか、ぐらいがいい。

- ひとつのオブジェクトの読み込みを多段階にする
- ことなるルーチンがことなる部分を要求する、など

### レイジーイニシャライズ

フィールドが null だったら読み込む。

オブジェクトと DB が密結合するので、アクティブレコード、テーブルデータゲートウェイ、行データゲートウェイに適する。

### 仮想プロキシー

データマッパーの場合の間接化。

プロキシと実オブジェクトの対応関係に注意(適切な equality の実装)。

コレクションクラスについて使うと問題は少ない。

### バリューホルダー

いくつかのオブジェクトをラップするオブジェクト。最初の要求でだけ DB から読み込み、あとは持っているものを返す。

実装は局所的な identity map のような雰囲気?

### ゴースト

最初は ID だけ持っていて、要求されたときにすべてのフィールドを読み込む。
ゴーストを一意マッピングに挿入すれば循環参照問題(chap. 10, p.181)を自然に回避できる。
一部のよくつかうフィールドを読み込んでおいてもいい(軽オブジェクト)。

AOP やメタプログラミングが難しい状況では使いにくいかもしれない。

### その他の注意点

リプルローディングの問題。コレクションの要素を lazy load にするとコレクションに each するとき、毎回 DB アクセスが発生する。
コレクション全体を一度に読み込む lazy object にすると効果的。
より複雑なケースでは Value List Handler を使う。

- [Core J2EE Patterns - ValueListHandler](http://www.corej2eepatterns.com/Patterns2ndEd/ValueListHandler.htm)
- [Value List Handler - Strategic Choice - はてなダイアリー](http://d.hatena.ne.jp/asakichy/20090902/1251846210)

アスペクト指向プログラミングで利用すると効率的。

### 使用するタイミング

そのフィールドを取得すると DB の追加呼び出しが起きるような場合。

コード例はゴースト以外容易に把握できる。ゴーストは概念はシンプルなのに長い…
リプルローディング防止のための lazy list の実装例はゴーストの例に含まれている。
