# Chapter9 ドメインロジックパターン
## トランザクションスクリプト

ビジネスロジックを一連の手続きで構築し、各手順でプレゼンテーションからの１つの要求を処理する。

* 主な呼び出し方法
    1. ロジックを１つの手続きにまとめてデータベースを直接呼び出す
    2, 薄いデータベースラッパーを介した呼び出し

### 動作方法 
* ドメインロジックはシステム上で実行するトランザクションで主に構築
* どこに配置するか -> レイヤをどのように体系化するかによる
    * ファウラーはできる限りトランザクションスクリプトを分離させることを好んでいる
    * トランザクションスクリプトからプロゼンテーションロジックを呼び出さないようにする
* 複数のクラスに体系化する方法
    1. 複数のトランザクションスクリプトを１つのクラスに入れ、各クラスが関連するトランザクションスクリプトの対象エリアを定義
    2. トランザクションスクリプトごとに独自のクラスを持たせ、コマンドパターンを使う

### 使用するタイミング
* ロジックがシンプルな場合
* 複雑になりそうだったら初期段階からドメインモデルを使うべき

## ドメインモデル
振る舞いとデータの両方を一体化させたドメインのオブジェクトモデル

* 相互に関連するオブジェクトが絡み合った関係を作成

### 動作方法
* ドメインモデルの使用=対象となるビジネスエリアをモデル化したオブジェクトの例や全体の挿入
* ドメインモデルのデータベースモデルとの違い
    1. データとプロセスの一体化
    2. 複数地属性や複雑に絡み合う関係の存在
    3. 継承の使用
* シンプルなドメインモデル
    * ほとんどがデータベーステーブルごとに１ドメインオブジェクトを持つ形式
    * アクティブレコードを利用可能
* 豊富なドメインモデル
    * 複雑なロジックを扱うのに適している
    * データマッパーが必要
* ドメインオブジェクトの肥大化するリスク
    * 責任が一般的：そのクラスに置く
    * 責任が一般的でない：特定用途向けクラスに置く
        * トランザクションスクリプト
        * プレゼンテーション自体
        * 振る舞いが重複する可能性
    * 思ったほど頻繁には起こらない
    * 特定の状況での振る舞いを別にしないこと推奨
* J2EEの話
    * エンティティBeanの問題
    * 複雑な場合はPOJOドメインモデルとデータマッパーや商用ツール、自作レイヤを使うほうが賢い
    * JavaEE6ではこのあたりどうなっているのか？

### 使用するタイミング
* システム内の振る舞いの複雑性次第
* 開発チームがドメインオブジェクトを扱うスキルがあるか否か
    * ドメインモデルに慣れるには訓練と学習が必要
* データベース相互作用の関係でデータマッパーを使う
* サービスレイヤの使用検討

## テーブルモジュール
データベーステーブルがビューすべての行に関するビジネスロジックを扱うシングルインスタンス

### 動作方法
* テーブルモジュールのメリット
    * データと振る舞いを1つのパッケージにできる
    * リレーショナルデータベースのメリットを活かせる
* オブジェクトとの最大の違いは、作業対象となるオブジェクトに対する一意性の概念がない点
* テーブル指向のバッキングデータ構造で使用
* 多くの場合、複数のテーブルモジュールが同じレコードセットを操作する
* 実装はインスタンス or 静的メソッドの集まり
    * インスタンスの場合、既存のレコードセットで初期化可能
    * インスタンスは継承の使用が可能
* クエリーをファクトリメソッドとして含められる
* テーブルデータゲートウェイを使う方法もある
    * 設計内に余計なゲートウェイクラスとメカニズムが含まれることに
    * 異なるデータソースからのデータに対して1つのテーブルモジュールを使える
* 1つのテーブルに対して1つのテーブルモジュールを使用
    * 完全に正しいというわけではない
* 構造はアプリケーションで認識される仮想テーブルに依存したものになる

### 使用するタイミング
1. レコードセットを使ってテーブル形式のデータにアクセスしている場合
    * 複雑なドメインロジックはドメインモデルのほうが適している
    * 機能性のドメインモデルをとるか、統合性のテーブルモジュールをとるか
2. 共通のテーブル指向のデータ構造をベースにしている場合

## サービスレイヤ
サービスとレイヤのアプリケーションの境界を定義する。
サービスは利用できる操作セットを設定し、各操作に対するアプリケーションのレスポンスを調整するものである。

* アプリケーションのビジネスロジックをカプセル化
* トランザクションを制御
* 操作の実装におけるレスポンスを調整

### 動作方法
* いくつかの異なる方法で実装可能
    * サービスレイヤインタフェースに対する責任の割り当ての違い
* ビジネスロジックの種類
    * ドメインロジック
    * アプリケーションロジック
* 実装バリエーション
    * ドメインファサード的手法
        * ドメインモデル上の薄いファサードのセットとして実装
        * ビジネスロジックはすべてドメインモデルによって実装
    * 操作スクリプト手法
        * アプリケーションロジックは直接実装
        * ドメインロジックはカプセル化されたドメインクラスに委譲
* リモートにするべきか否か
    * インタフェースの粒度から見るとリモート呼び出しに適したものになる
    * サービスレイヤのメソッドシグネチャをデータ変換オブジェクトで扱えるようにするには、相当な追加作業が必要
    * ローカルで呼び出せ、メソッドシグネチャがドメインロジック内で処理できるサービスレイヤから始めることを推奨
    * 本当に必要になった時点で行う
        * リモートファサードをサービスレイヤ上に置く
        * サービスレイヤオブジェクトにリモートインタフェースを実装
* サービスと操作の特定
    * 最も重要なものはユーザインタフェース
        * 最初のものでもある
    * 操作の特定はユースケースモデルとアプリケーション固有のユーザインタフェースから始めるべき
    * 実情：多くのエンタープライズアプリケーションのユースケースはCRUDユースケース
    * Javaでの実装
        * POJOとEJBの好きなほうを選択すればいい

### 使用するタイミング
* メリット
    1. 多様なアプリケーションが利用できるアプリケーションの共通の操作セットを定義する
    2. 各操作でのアプリケーションのレスポンスを調整
* いつ使うべきでないか
    * ビジネスロジックが1種類のクライアントしか持たず、ユースケースのレスポンスにマルチトランザクションリソースが関連していない場合
* 最初からサービスレイヤで設計したほうが効率的な場合
    * 違う種類のクライアント
    * ユースケースのレスポンスにおける別のトランザクションリソースの考えがでてきたとき

